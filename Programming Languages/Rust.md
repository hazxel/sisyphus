# Binding & Ownership

### 绑定

在其它语言中，我们使用赋值语句，将`=`右边的值赋予变量，而在 Rust 中，这一过程被称为**“绑定”**。

绑定这个名字隐含了 Rust 最核心的原则——**所有权**。Rust 中任何内存对象都有 owner，将对象绑定到变量后，变量成为了该内存对象的主人（此时先前的主人失去所有权）。

### Rust 所有权模型

Rust 中所有权模型的核心原则是**独占性**，即每个对象只能有一个 owner。这确保了内存安全，避免了数据竞争。

在绑定时或函数传参时，直接传递不带 `&` 的对象表示**转移所有权**（ownership transfer）

### 绑定时的行为

基本数据类型：存在栈中，自动**拷贝**赋值。默认拷贝的类型包括：基本类型、固定大小数组`[i32; 3]`、引用等

```rust
let x = 5;
let y = x; // both x and y are valid
```

非基本类型：存储在堆上，不会自动拷贝，而是触发移动，即发生所有权的转移。如果**确实**需要深拷贝堆上的数据，可以使用 `clone` （需要实现 `Clone` trait, 比如 `Vec<T>` 和 `String`）

```rust
let s1 = String::from("hello");
let s2 = s1; // s1 becomes invalid
let s3 = s1.clone();
```



# Mutability 可变性

Rust 的变量在默认情况下是**不可变的**。这让代码更安全，性能也更好。

可以通过 `mut` 关键字让变量变为**可变的**。



# Borrow 借用

在 Rust 中，`&` 符号表示 borrow，借用的规则：

- 在同一作用域中，任意时刻只能有一个可变借用（`&mut`）。
- 如果存在可变借用，则不能有任何不可变借用（`&`）。
- 可以同时存在多个不可变借用（`&`），但在此期间不能有可变借用。



# Struct

```rust
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    // new是Circle的关联函数，因为它的第一个参数不是self，且new并不是关键字
    // 这种方法往往用于初始化当前结构体的实例
    fn new(x: f64, y: f64, radius: f64) -> Circle {
        Circle {
            x: x,
            y: y,
            radius: radius,
        }
    }

    // Circle的方法，&self表示借用当前的Circle结构体
    fn area(&self) -> f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}
```



需要注意的是，`self` 有所有权的概念：

- `self` 表示所有权转移到该方法中，这种形式用的较少
- `&self` 表示不可变借用
- `&mut self` 表示可变借用

> 和 python 不同，Rust 中 `self` 是关键字，用于方法定义中以表示方法调用的接收者，不能使用其他名称代替。



# Generics & Traits

### Generics 泛型

泛型就是一种（编译期）多态，减少重复代码，丰富语言的表达力。

##### 泛型函数

```rust
fn add<T>(a:T, b:T) -> T {
    a + b
}
```

##### 泛型结构体

```rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T { &self.x }
    fn y(&self) -> &T { &self.y }
}

impl Point<f32> {
    fn x(&self) -> f32 { 0 }
}
```



### Traits 特征

Traits 被用于定义某种 general 的行为，不规定实现，不同的具体类型需要自行实现 Traits 。

```rust
pub trait Summary {
    fn summarize(&self) -> String;
}
pub struct Post {
    pub title: String,
    pub content: String,
}
impl Summary for Post {
    fn summarize(&self) -> String { format!("{}: {}", self.title, self.author) }
}
```

可以使用 Traits 作为函数参数：

```rust
pub fn notify(item: &impl Summary) { // syntax candy
    println!("Breaking news! {}", item.summarize());
}
pub fn notify<T: Summary>(item: &T) { // full formal syntax
    println!("Breaking news! {}", item.summarize());
}
```





# 生命周期

### 借用检查

存在借用关系时，Rust 会在编译期比较他们的生命周期，引用比自身的生命周期小的对象会无法通过编译。

### 生命周期标注

在存在多个引用时，编译器有时会无法自动推导生命周期，此时就需要我们手动去标注，通过为参数标注合适的生命周期来帮助编译器进行借用检查的分析。

##### 函数

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}
```

##### 结构体

```rust
struct Message<'a> {
    part: &'a str,
}
```



### 生命周期消除

为简化用户的使用，编译器使用三条消除规则来确定哪些场景不需要显式地去标注生命周期。

其中第一条应用于输入生命周期，第二、三条应用于输出生命周期。三条规则都不适用时，必须手动标注。

1. 每一个引用参数都会获得独自的生命周期

   例如一个引用参数的函数就有一个生命周期标注: `fn foo<'a>(x: &'a i32)`，两个引用参数的有两个生命周期标注:`fn foo<'a, 'b>(x: &'a i32, y: &'b i32)`, 依此类推。

2. 若只有一个输入生命周期(函数参数中只有一个引用类型)，那么该生命周期会被赋给所有的输出生命周期，也就是所有返回值的生命周期都等于该输入生命周期

   例如函数 `fn foo(x: &i32) -> &i32`，`x` 参数的生命周期会被自动赋给返回值 `&i32`，因此该函数等同于 `fn foo<'a>(x: &'a i32) -> &'a i32`

3. 若存在多个输入生命周期，且其中一个是 `&self` 或 `&mut self`，则 `&self` 的生命周期被赋给所有的输出生命周期

   拥有 `&self` 形式的参数，说明该函数是一个 `方法`，该规则让方法的使用便利度大幅提升。

# Box

智能指针



# Vector

### Initialization

```rust
let v = vec![0; 3];
let v = Vec::from([0, 0, 0]);
let v: Vec<i32> = Vec::new();
```

### Modify

```rust
v.insert(2, 3);
assert_eq!(v.remove(1), 2);
assert_eq!(v.pop(), Some(3));
assert_eq!(v.pop(), None);
v.clear();
```



# HashMap

### `or_insert` vs `or_insert_with`

Ensures a value is in the entry, value passed by value or generated by given function. 主要差别在于，key 存在时，由于不需要做任何操作，pass funciton 的开销较小。



# String

Rust 中有两种字符串类型：`String` 和 `&str`。

`String` 被存储为由字节组成的 vector（`Vec<u8>`），但保证了它一定是一个有效的 UTF-8 序列。`String` 是堆分配的，可增长的，且不是零结尾的（null terminated）。

`&str` 是一个总是指向有效 UTF-8 序列的切片（`&[u8]`），并可用来查看 `String` 的内容，就如同 `&[T]` 是 `Vec<T>` 的全部或部分引用。
